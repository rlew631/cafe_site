{"ast":null,"code":"import { __assign, __read, __values } from 'tslib';\nimport { objectEntries } from '../utils.js';\nimport { dict } from './dict.js';\n\nfunction dictWithXmlEntries(itemSchema) {\n  var dictSchema = dict(itemSchema);\n\n  var modifiedSchema = __assign({}, dictSchema);\n\n  modifiedSchema.unmapXml = function (inputValue, ctxt) {\n    var output = dictSchema.unmapXml(inputValue, ctxt); // Convert each entry to XML \"entry\" elements. The XML \"entry\" element looks\n    // like this: `<entry key=\"key\">value</entry>`. Note that the element name\n    // \"entry\" is set later at the return.\n\n    var entries = objectEntries(output).map(function (_a) {\n      var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n\n      return {\n        $: {\n          key: key\n        },\n        _: value\n      };\n    });\n    return {\n      entry: entries\n    };\n  };\n\n  modifiedSchema.mapXml = function (value, ctxt) {\n    var e_1, _a; // Empty dictionary\n\n\n    if (!('entry' in value)) {\n      return {};\n    }\n\n    var entries = value.entry; // For a single entry, the XML parser gives a single object instead of an array.\n    // Make it an array for easier handling.\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    } // Convert entry elements containing a key attribute and content to a dictionary.\n\n\n    var dictObj = {};\n\n    try {\n      for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {\n        var item = entries_1_1.value;\n        dictObj[item.$.key] = item._;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Run validation on entry values against the item schema.\n    // TODO: Maintain context and path when delegating validatin\n\n\n    return dictSchema.mapXml(dictObj, ctxt);\n  };\n\n  modifiedSchema.validateBeforeMapXml = function (value, ctxt) {\n    var e_2, _a;\n\n    if (typeof value !== 'object' || value === null) {\n      return ctxt.fail();\n    } // Empty dictionary case\n\n\n    if (!('entry' in value)) {\n      return [];\n    }\n\n    var entries = value.entry; // Non-repeating XML elements are passed as a single-object instead of an array of objects.\n    // We normalize this behavior of the XML parser.\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    } // Dictionary for all entries\n\n\n    var dictObj = {};\n\n    try {\n      for (var entries_2 = __values(entries), entries_2_1 = entries_2.next(); !entries_2_1.done; entries_2_1 = entries_2.next()) {\n        var entry = entries_2_1.value; // Fail if entry is not an XML element object.\n\n        if (typeof entry !== 'object' || entry === null) {\n          return ctxt.fail('Expected \"entry\" to be an XML element.');\n        } // Fail if entry does not have an attribute named key.\n\n\n        if (!('$' in entry) || !('key' in entry.$)) {\n          return ctxt.fail('Expected \"entry\" element to have an attribute named \"key\".');\n        } // Set entry in dictionary\n\n\n        var typedEntry = entry;\n        dictObj[typedEntry.$.key] = typedEntry._;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (entries_2_1 && !entries_2_1.done && (_a = entries_2.return)) _a.call(entries_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    } // Check all entry values against the item schema.\n    // TODO: Maintain context and path when delegating validation\n\n\n    return dictSchema.validateBeforeMapXml(dictObj, ctxt);\n  };\n\n  return modifiedSchema;\n}\n\nexport { dictWithXmlEntries };","map":{"version":3,"sources":["/Users/rlew/Documents/fullstack/cafe_site/node_modules/@apimatic/schema/es/types/dictWithXmlEntries.js"],"names":["__assign","__read","__values","objectEntries","dict","dictWithXmlEntries","itemSchema","dictSchema","modifiedSchema","unmapXml","inputValue","ctxt","output","entries","map","_a","_b","key","value","$","_","entry","mapXml","e_1","Array","isArray","dictObj","entries_1","entries_1_1","next","done","item","e_1_1","error","return","call","validateBeforeMapXml","e_2","fail","entries_2","entries_2_1","typedEntry","e_2_1"],"mappings":"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","sourcesContent":["import { __assign, __read, __values } from 'tslib';\nimport { objectEntries } from '../utils.js';\nimport { dict } from './dict.js';\n\nfunction dictWithXmlEntries(itemSchema) {\n  var dictSchema = dict(itemSchema);\n\n  var modifiedSchema = __assign({}, dictSchema);\n\n  modifiedSchema.unmapXml = function (inputValue, ctxt) {\n    var output = dictSchema.unmapXml(inputValue, ctxt); // Convert each entry to XML \"entry\" elements. The XML \"entry\" element looks\n    // like this: `<entry key=\"key\">value</entry>`. Note that the element name\n    // \"entry\" is set later at the return.\n\n    var entries = objectEntries(output).map(function (_a) {\n      var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n\n      return {\n        $: {\n          key: key\n        },\n        _: value\n      };\n    });\n    return {\n      entry: entries\n    };\n  };\n\n  modifiedSchema.mapXml = function (value, ctxt) {\n    var e_1, _a; // Empty dictionary\n\n\n    if (!('entry' in value)) {\n      return {};\n    }\n\n    var entries = value.entry; // For a single entry, the XML parser gives a single object instead of an array.\n    // Make it an array for easier handling.\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    } // Convert entry elements containing a key attribute and content to a dictionary.\n\n\n    var dictObj = {};\n\n    try {\n      for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {\n        var item = entries_1_1.value;\n        dictObj[item.$.key] = item._;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Run validation on entry values against the item schema.\n    // TODO: Maintain context and path when delegating validatin\n\n\n    return dictSchema.mapXml(dictObj, ctxt);\n  };\n\n  modifiedSchema.validateBeforeMapXml = function (value, ctxt) {\n    var e_2, _a;\n\n    if (typeof value !== 'object' || value === null) {\n      return ctxt.fail();\n    } // Empty dictionary case\n\n\n    if (!('entry' in value)) {\n      return [];\n    }\n\n    var entries = value.entry; // Non-repeating XML elements are passed as a single-object instead of an array of objects.\n    // We normalize this behavior of the XML parser.\n\n    if (!Array.isArray(entries)) {\n      entries = [entries];\n    } // Dictionary for all entries\n\n\n    var dictObj = {};\n\n    try {\n      for (var entries_2 = __values(entries), entries_2_1 = entries_2.next(); !entries_2_1.done; entries_2_1 = entries_2.next()) {\n        var entry = entries_2_1.value; // Fail if entry is not an XML element object.\n\n        if (typeof entry !== 'object' || entry === null) {\n          return ctxt.fail('Expected \"entry\" to be an XML element.');\n        } // Fail if entry does not have an attribute named key.\n\n\n        if (!('$' in entry) || !('key' in entry.$)) {\n          return ctxt.fail('Expected \"entry\" element to have an attribute named \"key\".');\n        } // Set entry in dictionary\n\n\n        var typedEntry = entry;\n        dictObj[typedEntry.$.key] = typedEntry._;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (entries_2_1 && !entries_2_1.done && (_a = entries_2.return)) _a.call(entries_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    } // Check all entry values against the item schema.\n    // TODO: Maintain context and path when delegating validation\n\n\n    return dictSchema.validateBeforeMapXml(dictObj, ctxt);\n  };\n\n  return modifiedSchema;\n}\n\nexport { dictWithXmlEntries };"]},"metadata":{},"sourceType":"module"}