{"ast":null,"code":"import { __assign, __values, __awaiter, __generator } from 'tslib';\nimport axios from 'axios';\nimport isNode from 'detect-node';\nimport FormData from 'form-data';\nimport { isBlob } from '../apiHelper.js';\nimport { AbortError } from '../errors/abortError.js';\nimport { isFileWrapper } from '../fileWrapper.js';\nimport { mergeHeaders, setHeader, setHeaderIfNotSet, CONTENT_TYPE_HEADER, FORM_URLENCODED_CONTENT_TYPE } from './httpHeaders.js';\nimport { urlEncodeKeyValuePairs } from './queryString.js';\n/**\r\n * bandwidthLib\r\n *\r\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\r\n */\n\nvar DEFAULT_AXIOS_CONFIG_OVERRIDES = {\n  transformResponse: []\n};\nvar DEFAULT_TIMEOUT = 30 * 1000;\n/**\r\n * HTTP client implementation.\r\n *\r\n * This implementation is a wrapper over the Axios client.\r\n */\n\nvar HttpClient =\n/*#__PURE__*/\n\n/** @class */\nfunction () {\n  function HttpClient(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        clientConfigOverrides = _b.clientConfigOverrides,\n        _c = _b.timeout,\n        timeout = _c === void 0 ? DEFAULT_TIMEOUT : _c;\n\n    this._timeout = timeout;\n    this._axiosInstance = axios.create(__assign(__assign({}, DEFAULT_AXIOS_CONFIG_OVERRIDES), clientConfigOverrides));\n  }\n  /** Converts an HttpRequest object to an Axios request. */\n\n\n  HttpClient.prototype.convertHttpRequest = function (req) {\n    var e_1, _a;\n\n    var _b, _c;\n\n    var newRequest = {\n      method: req.method,\n      url: req.url,\n      responseType: 'text',\n      headers: __assign({}, req.headers)\n    };\n\n    if (req.auth) {\n      // Set basic auth credentials if provided\n      newRequest.auth = {\n        username: req.auth.username,\n        password: req.auth.password || ''\n      };\n    }\n\n    var requestBody = req.body;\n\n    if ((requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'text') {\n      newRequest.data = requestBody.content;\n    } else if ((requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'form-data' && requestBody.content.some(function (item) {\n      return isFileWrapper(item.value);\n    })) {\n      // Create multipart request if a file is present\n      var form = new FormData();\n\n      try {\n        for (var _d = __values(requestBody.content), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var iter = _e.value;\n\n          if (isFileWrapper(iter.value)) {\n            var fileData = iter.value.file; // Make sure Blob has the correct content type if provided\n\n            if (isBlob(fileData) && ((_b = iter.value.options) === null || _b === void 0 ? void 0 : _b.contentType)) {\n              fileData = new Blob([fileData], {\n                type: iter.value.options.contentType\n              });\n            }\n\n            form.append(iter.key, fileData, iter.value.options);\n          } else {\n            form.append(iter.key, iter.value);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      newRequest.data = form;\n      mergeHeaders(newRequest.headers, form.getHeaders());\n    } else if ((requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'form-data' || (requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'form') {\n      // Create form-urlencoded request\n      setHeader(newRequest.headers, CONTENT_TYPE_HEADER, FORM_URLENCODED_CONTENT_TYPE);\n      newRequest.data = urlEncodeKeyValuePairs(requestBody.content);\n    } else if ((requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'stream') {\n      var contentType = 'application/octet-stream';\n\n      if (isBlob(requestBody.content.file) && requestBody.content.file.type) {\n        // Set Blob mime type as the content-type header if present\n        contentType = requestBody.content.file.type;\n      } else if ((_c = requestBody.content.options) === null || _c === void 0 ? void 0 : _c.contentType) {\n        // Otherwise, use the content type if available.\n        contentType = requestBody.content.options.contentType;\n      }\n\n      setHeaderIfNotSet(newRequest.headers, CONTENT_TYPE_HEADER, contentType);\n      newRequest.data = requestBody.content.file;\n    }\n\n    if (req.responseType === 'stream') {\n      newRequest.responseType = isNode ? 'stream' : 'blob';\n    } // Prevent superagent from converting any status code to error\n\n\n    newRequest.validateStatus = function () {\n      return true;\n    }; // Set 30 seconds timeout\n\n\n    newRequest.timeout = this._timeout;\n    return newRequest;\n  };\n  /** Converts an Axios response to an HttpResponse object. */\n\n\n  HttpClient.prototype.convertHttpResponse = function (resp) {\n    return {\n      body: resp.data,\n      headers: resp.headers,\n      statusCode: resp.status\n    };\n  };\n  /**\r\n   * Executes the HttpRequest with the given options and returns the HttpResponse\r\n   * or throws an error.\r\n   */\n\n\n  HttpClient.prototype.executeRequest = function (request, requestOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var axiosRequest, cancelToken_1, _a, error_1;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            axiosRequest = this.convertHttpRequest(request);\n\n            if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal) {\n              // throw if already aborted; do not place HTTP call\n              if (requestOptions.abortSignal.aborted) {\n                throw this.abortError();\n              }\n\n              cancelToken_1 = axios.CancelToken.source();\n              axiosRequest.cancelToken = cancelToken_1.token; // attach abort event handler\n\n              requestOptions.abortSignal.addEventListener('abort', function () {\n                cancelToken_1.cancel();\n              });\n            }\n\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            _a = this.convertHttpResponse;\n            return [4\n            /*yield*/\n            , this._axiosInstance(axiosRequest)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.apply(this, [_b.sent()])];\n\n          case 3:\n            error_1 = _b.sent(); // abort error should be thrown as the AbortError\n\n            if (axios.isCancel(error_1)) {\n              throw this.abortError();\n            }\n\n            throw error_1;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpClient.prototype.abortError = function () {\n    return new AbortError('The HTTP call was aborted.');\n  };\n\n  return HttpClient;\n}();\n\nexport { DEFAULT_AXIOS_CONFIG_OVERRIDES, DEFAULT_TIMEOUT, HttpClient };","map":{"version":3,"sources":["/Users/rlew/Documents/fullstack/cafe_site/node_modules/@apimatic/core/es/http/httpClient.js"],"names":["__assign","__values","__awaiter","__generator","axios","isNode","FormData","isBlob","AbortError","isFileWrapper","mergeHeaders","setHeader","setHeaderIfNotSet","CONTENT_TYPE_HEADER","FORM_URLENCODED_CONTENT_TYPE","urlEncodeKeyValuePairs","DEFAULT_AXIOS_CONFIG_OVERRIDES","transformResponse","DEFAULT_TIMEOUT","HttpClient","_a","_b","clientConfigOverrides","_c","timeout","_timeout","_axiosInstance","create","prototype","convertHttpRequest","req","e_1","newRequest","method","url","responseType","headers","auth","username","password","requestBody","body","type","data","content","some","item","value","form","_d","_e","next","done","iter","fileData","file","options","contentType","Blob","append","key","e_1_1","error","return","call","getHeaders","validateStatus","convertHttpResponse","resp","statusCode","status","executeRequest","request","requestOptions","axiosRequest","cancelToken_1","error_1","label","abortSignal","aborted","abortError","CancelToken","source","cancelToken","token","addEventListener","cancel","trys","push","apply","sent","isCancel"],"mappings":"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","sourcesContent":["import { __assign, __values, __awaiter, __generator } from 'tslib';\nimport axios from 'axios';\nimport isNode from 'detect-node';\nimport FormData from 'form-data';\nimport { isBlob } from '../apiHelper.js';\nimport { AbortError } from '../errors/abortError.js';\nimport { isFileWrapper } from '../fileWrapper.js';\nimport { mergeHeaders, setHeader, setHeaderIfNotSet, CONTENT_TYPE_HEADER, FORM_URLENCODED_CONTENT_TYPE } from './httpHeaders.js';\nimport { urlEncodeKeyValuePairs } from './queryString.js';\n/**\r\n * bandwidthLib\r\n *\r\n * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).\r\n */\n\nvar DEFAULT_AXIOS_CONFIG_OVERRIDES = {\n  transformResponse: []\n};\nvar DEFAULT_TIMEOUT = 30 * 1000;\n/**\r\n * HTTP client implementation.\r\n *\r\n * This implementation is a wrapper over the Axios client.\r\n */\n\nvar HttpClient =\n/*#__PURE__*/\n\n/** @class */\nfunction () {\n  function HttpClient(_a) {\n    var _b = _a === void 0 ? {} : _a,\n        clientConfigOverrides = _b.clientConfigOverrides,\n        _c = _b.timeout,\n        timeout = _c === void 0 ? DEFAULT_TIMEOUT : _c;\n\n    this._timeout = timeout;\n    this._axiosInstance = axios.create(__assign(__assign({}, DEFAULT_AXIOS_CONFIG_OVERRIDES), clientConfigOverrides));\n  }\n  /** Converts an HttpRequest object to an Axios request. */\n\n\n  HttpClient.prototype.convertHttpRequest = function (req) {\n    var e_1, _a;\n\n    var _b, _c;\n\n    var newRequest = {\n      method: req.method,\n      url: req.url,\n      responseType: 'text',\n      headers: __assign({}, req.headers)\n    };\n\n    if (req.auth) {\n      // Set basic auth credentials if provided\n      newRequest.auth = {\n        username: req.auth.username,\n        password: req.auth.password || ''\n      };\n    }\n\n    var requestBody = req.body;\n\n    if ((requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'text') {\n      newRequest.data = requestBody.content;\n    } else if ((requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'form-data' && requestBody.content.some(function (item) {\n      return isFileWrapper(item.value);\n    })) {\n      // Create multipart request if a file is present\n      var form = new FormData();\n\n      try {\n        for (var _d = __values(requestBody.content), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var iter = _e.value;\n\n          if (isFileWrapper(iter.value)) {\n            var fileData = iter.value.file; // Make sure Blob has the correct content type if provided\n\n            if (isBlob(fileData) && ((_b = iter.value.options) === null || _b === void 0 ? void 0 : _b.contentType)) {\n              fileData = new Blob([fileData], {\n                type: iter.value.options.contentType\n              });\n            }\n\n            form.append(iter.key, fileData, iter.value.options);\n          } else {\n            form.append(iter.key, iter.value);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      newRequest.data = form;\n      mergeHeaders(newRequest.headers, form.getHeaders());\n    } else if ((requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'form-data' || (requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'form') {\n      // Create form-urlencoded request\n      setHeader(newRequest.headers, CONTENT_TYPE_HEADER, FORM_URLENCODED_CONTENT_TYPE);\n      newRequest.data = urlEncodeKeyValuePairs(requestBody.content);\n    } else if ((requestBody === null || requestBody === void 0 ? void 0 : requestBody.type) === 'stream') {\n      var contentType = 'application/octet-stream';\n\n      if (isBlob(requestBody.content.file) && requestBody.content.file.type) {\n        // Set Blob mime type as the content-type header if present\n        contentType = requestBody.content.file.type;\n      } else if ((_c = requestBody.content.options) === null || _c === void 0 ? void 0 : _c.contentType) {\n        // Otherwise, use the content type if available.\n        contentType = requestBody.content.options.contentType;\n      }\n\n      setHeaderIfNotSet(newRequest.headers, CONTENT_TYPE_HEADER, contentType);\n      newRequest.data = requestBody.content.file;\n    }\n\n    if (req.responseType === 'stream') {\n      newRequest.responseType = isNode ? 'stream' : 'blob';\n    } // Prevent superagent from converting any status code to error\n\n\n    newRequest.validateStatus = function () {\n      return true;\n    }; // Set 30 seconds timeout\n\n\n    newRequest.timeout = this._timeout;\n    return newRequest;\n  };\n  /** Converts an Axios response to an HttpResponse object. */\n\n\n  HttpClient.prototype.convertHttpResponse = function (resp) {\n    return {\n      body: resp.data,\n      headers: resp.headers,\n      statusCode: resp.status\n    };\n  };\n  /**\r\n   * Executes the HttpRequest with the given options and returns the HttpResponse\r\n   * or throws an error.\r\n   */\n\n\n  HttpClient.prototype.executeRequest = function (request, requestOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var axiosRequest, cancelToken_1, _a, error_1;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            axiosRequest = this.convertHttpRequest(request);\n\n            if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal) {\n              // throw if already aborted; do not place HTTP call\n              if (requestOptions.abortSignal.aborted) {\n                throw this.abortError();\n              }\n\n              cancelToken_1 = axios.CancelToken.source();\n              axiosRequest.cancelToken = cancelToken_1.token; // attach abort event handler\n\n              requestOptions.abortSignal.addEventListener('abort', function () {\n                cancelToken_1.cancel();\n              });\n            }\n\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            _a = this.convertHttpResponse;\n            return [4\n            /*yield*/\n            , this._axiosInstance(axiosRequest)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.apply(this, [_b.sent()])];\n\n          case 3:\n            error_1 = _b.sent(); // abort error should be thrown as the AbortError\n\n            if (axios.isCancel(error_1)) {\n              throw this.abortError();\n            }\n\n            throw error_1;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpClient.prototype.abortError = function () {\n    return new AbortError('The HTTP call was aborted.');\n  };\n\n  return HttpClient;\n}();\n\nexport { DEFAULT_AXIOS_CONFIG_OVERRIDES, DEFAULT_TIMEOUT, HttpClient };"]},"metadata":{},"sourceType":"module"}