{"ast":null,"code":"var fs = require('fs'),\n    EventEmitter = require('events').EventEmitter,\n    util = require('util');\n\nvar readLine = module.exports = function (file, opts) {\n  if (!(this instanceof readLine)) return new readLine(file, opts);\n  EventEmitter.call(this);\n  opts = opts || {};\n  opts.maxLineLength = opts.maxLineLength || 4096; // 4K\n\n  opts.retainBuffer = !!opts.retainBuffer; //do not convert to String prior to invoking emit 'line' event\n\n  var self = this,\n      lineBuffer = new Buffer(opts.maxLineLength),\n      lineLength = 0,\n      lineCount = 0,\n      byteCount = 0,\n      emit = function (lineCount, byteCount) {\n    try {\n      var line = lineBuffer.slice(0, lineLength);\n      self.emit('line', opts.retainBuffer ? line : line.toString(), lineCount, byteCount);\n    } catch (err) {\n      self.emit('error', err);\n    } finally {\n      lineLength = 0; // Empty buffer.\n    }\n  };\n\n  this.input = 'string' === typeof file ? fs.createReadStream(file, opts) : file;\n  this.input.on('open', function (fd) {\n    self.emit('open', fd);\n  }).on('data', function (data) {\n    for (var i = 0; i < data.length; i++) {\n      if (data[i] == 10 || data[i] == 13) {\n        // Newline char was found.\n        if (data[i] == 10) {\n          lineCount++;\n          emit(lineCount, byteCount);\n        }\n      } else {\n        lineBuffer[lineLength] = data[i]; // Buffer new line data.\n\n        lineLength++;\n      }\n\n      byteCount++;\n    }\n  }).on('error', function (err) {\n    self.emit('error', err);\n  }).on('end', function () {\n    // Emit last line if anything left over since EOF won't trigger it.\n    if (lineLength) {\n      lineCount++;\n      emit(lineCount, byteCount);\n    }\n\n    self.emit('end');\n  }).on('close', function () {\n    self.emit('close');\n  });\n};\n\nutil.inherits(readLine, EventEmitter);","map":{"version":3,"sources":["/Users/rlew/Documents/fullstack/cafe_site/node_modules/readline/readline.js"],"names":["fs","require","EventEmitter","util","readLine","module","exports","file","opts","call","maxLineLength","retainBuffer","self","lineBuffer","Buffer","lineLength","lineCount","byteCount","emit","line","slice","toString","err","input","createReadStream","on","fd","data","i","length","inherits"],"mappings":"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","sourcesContent":["var fs = require('fs'),\n    EventEmitter = require('events').EventEmitter,\n    util = require('util');\n\nvar readLine = module.exports = function(file, opts) {\n  if (!(this instanceof readLine)) return new readLine(file, opts);\n\n  EventEmitter.call(this);\n  opts = opts || {};\n  opts.maxLineLength = opts.maxLineLength || 4096; // 4K\n  opts.retainBuffer = !!opts.retainBuffer; //do not convert to String prior to invoking emit 'line' event\n  var self = this,\n      lineBuffer = new Buffer(opts.maxLineLength),\n      lineLength = 0,\n      lineCount = 0,\n      byteCount = 0,\n      emit = function(lineCount, byteCount) {\n        try {\n          var line = lineBuffer.slice(0, lineLength);\n          self.emit('line', opts.retainBuffer? line : line.toString(), lineCount, byteCount);\n        } catch (err) {\n          self.emit('error', err);\n        } finally {\n          lineLength = 0; // Empty buffer.\n        }\n      };\n  this.input = ('string' === typeof file) ? fs.createReadStream(file, opts) : file;\n  this.input.on('open', function(fd) {\n      self.emit('open', fd);\n    })\n    .on('data', function(data) {\n      for (var i = 0; i < data.length; i++) {\n        if (data[i] == 10 || data[i] == 13) { // Newline char was found.\n          if (data[i] == 10) {\n            lineCount++;\n            emit(lineCount, byteCount);\n          }\n        } else {\n          lineBuffer[lineLength] = data[i]; // Buffer new line data.\n          lineLength++;\n        }\n        byteCount++;\n      }\n    })\n    .on('error', function(err) {\n      self.emit('error', err);\n    })\n    .on('end', function() {\n      // Emit last line if anything left over since EOF won't trigger it.\n      if (lineLength) {\n        lineCount++;\n        emit(lineCount, byteCount);\n      }\n      self.emit('end');\n    })\n    .on('close', function() {\n      self.emit('close');\n    });\n};\nutil.inherits(readLine, EventEmitter);\n"]},"metadata":{},"sourceType":"script"}