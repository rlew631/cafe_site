{"ast":null,"code":"import { arrayEntries } from '../utils.js';\n/**\r\n * Create an array schema.\r\n *\r\n * The array must be a homogenous array confirming to the itemsSchema. Each item\r\n * will be mapped/unmapped using the itemsSchema.\r\n */\n\nfunction array(itemsSchema, xmlOptions) {\n  var arraySchema;\n  arraySchema = {\n    type: function type() {\n      return \"Array<\" + itemsSchema.type() + \">\";\n    },\n    validateBeforeMap: function validateBeforeMap(value, ctxt) {\n      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeMap(v[1], childCtxt);\n      }) : ctxt.fail();\n    },\n    validateBeforeUnmap: function validateBeforeUnmap(value, ctxt) {\n      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeUnmap(v[1], childCtxt);\n      }) : ctxt.fail();\n    },\n    map: function map(value, ctxt) {\n      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.map(v[1], childCtxt);\n      });\n    },\n    unmap: function unmap(value, ctxt) {\n      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.unmap(v[1], childCtxt);\n      });\n    },\n    mapXml: function mapXml(value, ctxt) {\n      var items = value;\n\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        items = value[xmlOptions.xmlItemName];\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\n      }\n\n      return ctxt.mapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.mapXml(v[1], childCtxt);\n      });\n    },\n    unmapXml: function unmapXml(value, ctxt) {\n      var _a;\n\n      var items = ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.unmapXml(v[1], childCtxt);\n      });\n\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        return _a = {}, _a[xmlOptions.xmlItemName] = items, _a;\n      } else {\n        return items;\n      }\n    },\n    validateBeforeMapXml: function validateBeforeMapXml(value, ctxt) {\n      var items = value;\n\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        var errorMessage = \"Expected array to be wrapped with XML element \" + xmlOptions.xmlItemName + \".\";\n\n        if (typeof value !== 'object' || value === null || !(xmlOptions.xmlItemName in value)) {\n          return ctxt.fail(errorMessage);\n        }\n\n        items = value[xmlOptions.xmlItemName];\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\n      }\n\n      return Array.isArray(items) ? ctxt.flatmapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeMapXml(v[1], childCtxt);\n      }) : ctxt.fail();\n    }\n  };\n  return arraySchema;\n}\n\nexport { array };","map":{"version":3,"sources":["/Users/rlew/Documents/fullstack/cafe_site/node_modules/@apimatic/schema/es/types/array.js"],"names":["arrayEntries","array","itemsSchema","xmlOptions","arraySchema","type","validateBeforeMap","value","ctxt","Array","isArray","flatmapChildren","v","childCtxt","fail","validateBeforeUnmap","map","mapChildren","unmap","mapXml","items","xmlItemName","createChild","unmapXml","_a","validateBeforeMapXml","errorMessage"],"mappings":"AAAA,SAASA,YAAT,QAA6B,aAA7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,KAAT,CAAeC,WAAf,EAA4BC,UAA5B,EAAwC;AACtC,MAAIC,WAAJ;AACAA,EAAAA,WAAW,GAAG;AACZC,IAAAA,IAAI,EAAE,gBAAY;AAChB,aAAO,WAAWH,WAAW,CAACG,IAAZ,EAAX,GAAgC,GAAvC;AACD,KAHW;AAIZC,IAAAA,iBAAiB,EAAE,2BAAUC,KAAV,EAAiBC,IAAjB,EAAuB;AACxC,aAAOC,KAAK,CAACC,OAAN,CAAcH,KAAd,IAAuBC,IAAI,CAACG,eAAL,CAAqBX,YAAY,CAACO,KAAD,CAAjC,EAA0CL,WAA1C,EAAuD,UAAUU,CAAV,EAAaC,SAAb,EAAwB;AAC3G,eAAOX,WAAW,CAACI,iBAAZ,CAA8BM,CAAC,CAAC,CAAD,CAA/B,EAAoCC,SAApC,CAAP;AACD,OAF6B,CAAvB,GAEFL,IAAI,CAACM,IAAL,EAFL;AAGD,KARW;AASZC,IAAAA,mBAAmB,EAAE,6BAAUR,KAAV,EAAiBC,IAAjB,EAAuB;AAC1C,aAAOC,KAAK,CAACC,OAAN,CAAcH,KAAd,IAAuBC,IAAI,CAACG,eAAL,CAAqBX,YAAY,CAACO,KAAD,CAAjC,EAA0CL,WAA1C,EAAuD,UAAUU,CAAV,EAAaC,SAAb,EAAwB;AAC3G,eAAOX,WAAW,CAACa,mBAAZ,CAAgCH,CAAC,CAAC,CAAD,CAAjC,EAAsCC,SAAtC,CAAP;AACD,OAF6B,CAAvB,GAEFL,IAAI,CAACM,IAAL,EAFL;AAGD,KAbW;AAcZE,IAAAA,GAAG,EAAE,aAAUT,KAAV,EAAiBC,IAAjB,EAAuB;AAC1B,aAAOA,IAAI,CAACS,WAAL,CAAiBjB,YAAY,CAACO,KAAD,CAA7B,EAAsCL,WAAtC,EAAmD,UAAUU,CAAV,EAAaC,SAAb,EAAwB;AAChF,eAAOX,WAAW,CAACc,GAAZ,CAAgBJ,CAAC,CAAC,CAAD,CAAjB,EAAsBC,SAAtB,CAAP;AACD,OAFM,CAAP;AAGD,KAlBW;AAmBZK,IAAAA,KAAK,EAAE,eAAUX,KAAV,EAAiBC,IAAjB,EAAuB;AAC5B,aAAOA,IAAI,CAACS,WAAL,CAAiBjB,YAAY,CAACO,KAAD,CAA7B,EAAsCL,WAAtC,EAAmD,UAAUU,CAAV,EAAaC,SAAb,EAAwB;AAChF,eAAOX,WAAW,CAACgB,KAAZ,CAAkBN,CAAC,CAAC,CAAD,CAAnB,EAAwBC,SAAxB,CAAP;AACD,OAFM,CAAP;AAGD,KAvBW;AAwBZM,IAAAA,MAAM,EAAE,gBAAUZ,KAAV,EAAiBC,IAAjB,EAAuB;AAC7B,UAAIY,KAAK,GAAGb,KAAZ;;AAEA,UAAIJ,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACkB,WAAvE,EAAoF;AAClFD,QAAAA,KAAK,GAAGb,KAAK,CAACJ,UAAU,CAACkB,WAAZ,CAAb;AACAb,QAAAA,IAAI,GAAGA,IAAI,CAACc,WAAL,CAAiBnB,UAAU,CAACkB,WAA5B,EAAyCD,KAAzC,EAAgDlB,WAAhD,CAAP;AACD;;AAED,aAAOM,IAAI,CAACS,WAAL,CAAiBjB,YAAY,CAACoB,KAAD,CAA7B,EAAsClB,WAAtC,EAAmD,UAAUU,CAAV,EAAaC,SAAb,EAAwB;AAChF,eAAOX,WAAW,CAACiB,MAAZ,CAAmBP,CAAC,CAAC,CAAD,CAApB,EAAyBC,SAAzB,CAAP;AACD,OAFM,CAAP;AAGD,KAnCW;AAoCZU,IAAAA,QAAQ,EAAE,kBAAUhB,KAAV,EAAiBC,IAAjB,EAAuB;AAC/B,UAAIgB,EAAJ;;AAEA,UAAIJ,KAAK,GAAGZ,IAAI,CAACS,WAAL,CAAiBjB,YAAY,CAACO,KAAD,CAA7B,EAAsCL,WAAtC,EAAmD,UAAUU,CAAV,EAAaC,SAAb,EAAwB;AACrF,eAAOX,WAAW,CAACqB,QAAZ,CAAqBX,CAAC,CAAC,CAAD,CAAtB,EAA2BC,SAA3B,CAAP;AACD,OAFW,CAAZ;;AAIA,UAAIV,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACkB,WAAvE,EAAoF;AAClF,eAAOG,EAAE,GAAG,EAAL,EAASA,EAAE,CAACrB,UAAU,CAACkB,WAAZ,CAAF,GAA6BD,KAAtC,EAA6CI,EAApD;AACD,OAFD,MAEO;AACL,eAAOJ,KAAP;AACD;AACF,KAhDW;AAiDZK,IAAAA,oBAAoB,EAAE,8BAAUlB,KAAV,EAAiBC,IAAjB,EAAuB;AAC3C,UAAIY,KAAK,GAAGb,KAAZ;;AAEA,UAAIJ,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACkB,WAAvE,EAAoF;AAClF,YAAIK,YAAY,GAAG,mDAAmDvB,UAAU,CAACkB,WAA9D,GAA4E,GAA/F;;AAEA,YAAI,OAAOd,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IAA+C,EAAEJ,UAAU,CAACkB,WAAX,IAA0Bd,KAA5B,CAAnD,EAAuF;AACrF,iBAAOC,IAAI,CAACM,IAAL,CAAUY,YAAV,CAAP;AACD;;AAEDN,QAAAA,KAAK,GAAGb,KAAK,CAACJ,UAAU,CAACkB,WAAZ,CAAb;AACAb,QAAAA,IAAI,GAAGA,IAAI,CAACc,WAAL,CAAiBnB,UAAU,CAACkB,WAA5B,EAAyCD,KAAzC,EAAgDlB,WAAhD,CAAP;AACD;;AAED,aAAOO,KAAK,CAACC,OAAN,CAAcU,KAAd,IAAuBZ,IAAI,CAACG,eAAL,CAAqBX,YAAY,CAACoB,KAAD,CAAjC,EAA0ClB,WAA1C,EAAuD,UAAUU,CAAV,EAAaC,SAAb,EAAwB;AAC3G,eAAOX,WAAW,CAACuB,oBAAZ,CAAiCb,CAAC,CAAC,CAAD,CAAlC,EAAuCC,SAAvC,CAAP;AACD,OAF6B,CAAvB,GAEFL,IAAI,CAACM,IAAL,EAFL;AAGD;AAlEW,GAAd;AAoEA,SAAOV,WAAP;AACD;;AAED,SAASH,KAAT","sourcesContent":["import { arrayEntries } from '../utils.js';\n/**\r\n * Create an array schema.\r\n *\r\n * The array must be a homogenous array confirming to the itemsSchema. Each item\r\n * will be mapped/unmapped using the itemsSchema.\r\n */\n\nfunction array(itemsSchema, xmlOptions) {\n  var arraySchema;\n  arraySchema = {\n    type: function () {\n      return \"Array<\" + itemsSchema.type() + \">\";\n    },\n    validateBeforeMap: function (value, ctxt) {\n      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeMap(v[1], childCtxt);\n      }) : ctxt.fail();\n    },\n    validateBeforeUnmap: function (value, ctxt) {\n      return Array.isArray(value) ? ctxt.flatmapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeUnmap(v[1], childCtxt);\n      }) : ctxt.fail();\n    },\n    map: function (value, ctxt) {\n      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.map(v[1], childCtxt);\n      });\n    },\n    unmap: function (value, ctxt) {\n      return ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.unmap(v[1], childCtxt);\n      });\n    },\n    mapXml: function (value, ctxt) {\n      var items = value;\n\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        items = value[xmlOptions.xmlItemName];\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\n      }\n\n      return ctxt.mapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.mapXml(v[1], childCtxt);\n      });\n    },\n    unmapXml: function (value, ctxt) {\n      var _a;\n\n      var items = ctxt.mapChildren(arrayEntries(value), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.unmapXml(v[1], childCtxt);\n      });\n\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        return _a = {}, _a[xmlOptions.xmlItemName] = items, _a;\n      } else {\n        return items;\n      }\n    },\n    validateBeforeMapXml: function (value, ctxt) {\n      var items = value;\n\n      if (xmlOptions === null || xmlOptions === void 0 ? void 0 : xmlOptions.xmlItemName) {\n        var errorMessage = \"Expected array to be wrapped with XML element \" + xmlOptions.xmlItemName + \".\";\n\n        if (typeof value !== 'object' || value === null || !(xmlOptions.xmlItemName in value)) {\n          return ctxt.fail(errorMessage);\n        }\n\n        items = value[xmlOptions.xmlItemName];\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\n      }\n\n      return Array.isArray(items) ? ctxt.flatmapChildren(arrayEntries(items), itemsSchema, function (v, childCtxt) {\n        return itemsSchema.validateBeforeMapXml(v[1], childCtxt);\n      }) : ctxt.fail();\n    }\n  };\n  return arraySchema;\n}\n\nexport { array };"]},"metadata":{},"sourceType":"module"}