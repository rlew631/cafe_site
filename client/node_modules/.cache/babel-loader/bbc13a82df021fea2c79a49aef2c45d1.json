{"ast":null,"code":"import { __assign, __spreadArray, __read, __values } from 'tslib';\nimport { objectKeyEncode } from './utils.js';\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after JSON deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\n\nfunction validateAndMap(value, schema) {\n  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));\n  var validationResult = schema.validateBeforeMap(value, contextCreator);\n\n  if (validationResult.length === 0) {\n    return {\n      errors: false,\n      result: schema.map(value, contextCreator)\n    };\n  } else {\n    return {\n      errors: validationResult\n    };\n  }\n}\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before JSON serializatin.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\n\n\nfunction validateAndUnmap(value, schema) {\n  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));\n  var validationResult = schema.validateBeforeUnmap(value, contextCreator);\n\n  if (validationResult.length === 0) {\n    return {\n      errors: false,\n      result: schema.unmap(value, contextCreator)\n    };\n  } else {\n    return {\n      errors: validationResult\n    };\n  }\n}\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after XML deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\n\n\nfunction validateAndMapXml(value, schema) {\n  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));\n  var validationResult = schema.validateBeforeMapXml(value, contextCreator);\n\n  if (validationResult.length === 0) {\n    return {\n      errors: false,\n      result: schema.mapXml(value, contextCreator)\n    };\n  } else {\n    return {\n      errors: validationResult\n    };\n  }\n}\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before XML serialization.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\n\n\nfunction validateAndUnmapXml(value, schema) {\n  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));\n  var validationResult = schema.validateBeforeUnmap(value, contextCreator);\n\n  if (validationResult.length === 0) {\n    return {\n      errors: false,\n      result: schema.unmapXml(value, contextCreator)\n    };\n  } else {\n    return {\n      errors: validationResult\n    };\n  }\n}\n/**\r\n * Create a new schema context using the given value and type.\r\n */\n\n\nfunction createNewSchemaContext(value, type) {\n  return {\n    value: value,\n    type: type,\n    branch: [value],\n    path: []\n  };\n}\n/**\r\n * Create a new SchemaContextCreator for the given SchemaContext.\r\n */\n\n\nfunction createSchemaContextCreator(currentContext) {\n  var createChildContext = function (key, value, childSchema) {\n    return createSchemaContextCreator({\n      value: value,\n      type: childSchema.type(),\n      branch: __spreadArray(__spreadArray([], __read(currentContext.branch)), [value]),\n      path: __spreadArray(__spreadArray([], __read(currentContext.path)), [key])\n    });\n  };\n\n  var mapChildren = function (items, itemSchema, mapper) {\n    return items.map(function (item) {\n      return mapper(item, createChildContext(item[0], item[1], itemSchema));\n    });\n  };\n\n  return __assign(__assign({}, currentContext), {\n    createChild: createChildContext,\n    flatmapChildren: function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return flatten(mapChildren.apply(void 0, __spreadArray([], __read(args))));\n    },\n    mapChildren: mapChildren,\n    fail: function (message) {\n      return [__assign(__assign({}, currentContext), {\n        message: createErrorMessage(currentContext, message)\n      })];\n    }\n  });\n}\n\nfunction createErrorMessage(ctxt, message) {\n  var giveValue = JSON.stringify(ctxt.value, function (_, value) {\n    return typeof value === 'bigint' ? value.toString() : value;\n  });\n  message = (message !== null && message !== void 0 ? message : \"Expected value to be of type '\" + ctxt.type + \"' but found '\" + typeof ctxt.value + \"'.\") + '\\n' + (\"\\nGiven value: \" + giveValue) + (\"\\nType: '\" + typeof ctxt.value + \"'\") + (\"\\nExpected type: '\" + ctxt.type + \"'\");\n\n  if (ctxt.path.length > 0) {\n    var pathString = ctxt.path.map(function (value) {\n      return objectKeyEncode(value.toString());\n    }).join(' › ');\n    message += \"\\nPath: \" + pathString;\n  }\n\n  return message;\n}\n\nfunction flatten(array) {\n  var e_1, _a, e_2, _b;\n\n  var output = [];\n\n  try {\n    for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {\n      var ele = array_1_1.value;\n\n      try {\n        for (var ele_1 = (e_2 = void 0, __values(ele)), ele_1_1 = ele_1.next(); !ele_1_1.done; ele_1_1 = ele_1.next()) {\n          var x = ele_1_1.value;\n          output.push(x);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (ele_1_1 && !ele_1_1.done && (_b = ele_1.return)) _b.call(ele_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return output;\n}\n\nexport { validateAndMap, validateAndMapXml, validateAndUnmap, validateAndUnmapXml };","map":{"version":3,"sources":["/Users/rlew/Documents/fullstack/cafe_site/node_modules/@apimatic/schema/es/schema.js"],"names":["__assign","__spreadArray","__read","__values","objectKeyEncode","validateAndMap","value","schema","contextCreator","createSchemaContextCreator","createNewSchemaContext","type","validationResult","validateBeforeMap","length","errors","result","map","validateAndUnmap","validateBeforeUnmap","unmap","validateAndMapXml","validateBeforeMapXml","mapXml","validateAndUnmapXml","unmapXml","branch","path","currentContext","createChildContext","key","childSchema","mapChildren","items","itemSchema","mapper","item","createChild","flatmapChildren","args","_i","arguments","flatten","apply","fail","message","createErrorMessage","ctxt","giveValue","JSON","stringify","_","toString","pathString","join","array","e_1","_a","e_2","_b","output","array_1","array_1_1","next","done","ele","ele_1","ele_1_1","x","push","e_2_1","error","return","call","e_1_1"],"mappings":"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","sourcesContent":["import { __assign, __spreadArray, __read, __values } from 'tslib';\nimport { objectKeyEncode } from './utils.js';\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after JSON deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\n\nfunction validateAndMap(value, schema) {\n  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));\n  var validationResult = schema.validateBeforeMap(value, contextCreator);\n\n  if (validationResult.length === 0) {\n    return {\n      errors: false,\n      result: schema.map(value, contextCreator)\n    };\n  } else {\n    return {\n      errors: validationResult\n    };\n  }\n}\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before JSON serializatin.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\n\n\nfunction validateAndUnmap(value, schema) {\n  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));\n  var validationResult = schema.validateBeforeUnmap(value, contextCreator);\n\n  if (validationResult.length === 0) {\n    return {\n      errors: false,\n      result: schema.unmap(value, contextCreator)\n    };\n  } else {\n    return {\n      errors: validationResult\n    };\n  }\n}\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after XML deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\n\n\nfunction validateAndMapXml(value, schema) {\n  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));\n  var validationResult = schema.validateBeforeMapXml(value, contextCreator);\n\n  if (validationResult.length === 0) {\n    return {\n      errors: false,\n      result: schema.mapXml(value, contextCreator)\n    };\n  } else {\n    return {\n      errors: validationResult\n    };\n  }\n}\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before XML serialization.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\n\n\nfunction validateAndUnmapXml(value, schema) {\n  var contextCreator = createSchemaContextCreator(createNewSchemaContext(value, schema.type()));\n  var validationResult = schema.validateBeforeUnmap(value, contextCreator);\n\n  if (validationResult.length === 0) {\n    return {\n      errors: false,\n      result: schema.unmapXml(value, contextCreator)\n    };\n  } else {\n    return {\n      errors: validationResult\n    };\n  }\n}\n/**\r\n * Create a new schema context using the given value and type.\r\n */\n\n\nfunction createNewSchemaContext(value, type) {\n  return {\n    value: value,\n    type: type,\n    branch: [value],\n    path: []\n  };\n}\n/**\r\n * Create a new SchemaContextCreator for the given SchemaContext.\r\n */\n\n\nfunction createSchemaContextCreator(currentContext) {\n  var createChildContext = function (key, value, childSchema) {\n    return createSchemaContextCreator({\n      value: value,\n      type: childSchema.type(),\n      branch: __spreadArray(__spreadArray([], __read(currentContext.branch)), [value]),\n      path: __spreadArray(__spreadArray([], __read(currentContext.path)), [key])\n    });\n  };\n\n  var mapChildren = function (items, itemSchema, mapper) {\n    return items.map(function (item) {\n      return mapper(item, createChildContext(item[0], item[1], itemSchema));\n    });\n  };\n\n  return __assign(__assign({}, currentContext), {\n    createChild: createChildContext,\n    flatmapChildren: function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return flatten(mapChildren.apply(void 0, __spreadArray([], __read(args))));\n    },\n    mapChildren: mapChildren,\n    fail: function (message) {\n      return [__assign(__assign({}, currentContext), {\n        message: createErrorMessage(currentContext, message)\n      })];\n    }\n  });\n}\n\nfunction createErrorMessage(ctxt, message) {\n  var giveValue = JSON.stringify(ctxt.value, function (_, value) {\n    return typeof value === 'bigint' ? value.toString() : value;\n  });\n  message = (message !== null && message !== void 0 ? message : \"Expected value to be of type '\" + ctxt.type + \"' but found '\" + typeof ctxt.value + \"'.\") + '\\n' + (\"\\nGiven value: \" + giveValue) + (\"\\nType: '\" + typeof ctxt.value + \"'\") + (\"\\nExpected type: '\" + ctxt.type + \"'\");\n\n  if (ctxt.path.length > 0) {\n    var pathString = ctxt.path.map(function (value) {\n      return objectKeyEncode(value.toString());\n    }).join(' › ');\n    message += \"\\nPath: \" + pathString;\n  }\n\n  return message;\n}\n\nfunction flatten(array) {\n  var e_1, _a, e_2, _b;\n\n  var output = [];\n\n  try {\n    for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {\n      var ele = array_1_1.value;\n\n      try {\n        for (var ele_1 = (e_2 = void 0, __values(ele)), ele_1_1 = ele_1.next(); !ele_1_1.done; ele_1_1 = ele_1.next()) {\n          var x = ele_1_1.value;\n          output.push(x);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (ele_1_1 && !ele_1_1.done && (_b = ele_1.return)) _b.call(ele_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return output;\n}\n\nexport { validateAndMap, validateAndMapXml, validateAndUnmap, validateAndUnmapXml };"]},"metadata":{},"sourceType":"module"}