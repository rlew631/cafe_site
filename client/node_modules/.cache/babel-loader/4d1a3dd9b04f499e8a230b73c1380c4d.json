{"ast":null,"code":"import { __spreadArray, __read } from 'tslib';\nimport { once } from '../utils.js';\n/**\r\n * Create a schema that lazily delegates to the given schema.\r\n */\n\nfunction lazy(schemaFn) {\n  var getSchema = once(schemaFn); // Memoize schema\n\n  return {\n    type: function type() {\n      return \"Lazy<\" + getSchema().type() + \">\";\n    },\n    map: function map() {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).map.apply(_a, __spreadArray([], __read(args)));\n    },\n    unmap: function unmap() {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).unmap.apply(_a, __spreadArray([], __read(args)));\n    },\n    validateBeforeMap: function validateBeforeMap() {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).validateBeforeMap.apply(_a, __spreadArray([], __read(args)));\n    },\n    validateBeforeUnmap: function validateBeforeUnmap() {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).validateBeforeUnmap.apply(_a, __spreadArray([], __read(args)));\n    },\n    mapXml: function mapXml() {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).mapXml.apply(_a, __spreadArray([], __read(args)));\n    },\n    unmapXml: function unmapXml() {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).unmapXml.apply(_a, __spreadArray([], __read(args)));\n    },\n    validateBeforeMapXml: function validateBeforeMapXml() {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).validateBeforeMapXml.apply(_a, __spreadArray([], __read(args)));\n    }\n  };\n}\n\nexport { lazy };","map":{"version":3,"sources":["/Users/rlew/Documents/fullstack/cafe_site/node_modules/@apimatic/schema/es/types/lazy.js"],"names":["__spreadArray","__read","once","lazy","schemaFn","getSchema","type","map","_a","args","_i","arguments","length","apply","unmap","validateBeforeMap","validateBeforeUnmap","mapXml","unmapXml","validateBeforeMapXml"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,MAAxB,QAAsC,OAAtC;AACA,SAASC,IAAT,QAAqB,aAArB;AACA;AACA;AACA;;AAEA,SAASC,IAAT,CAAcC,QAAd,EAAwB;AACtB,MAAIC,SAAS,GAAGH,IAAI,CAACE,QAAD,CAApB,CADsB,CACU;;AAEhC,SAAO;AACLE,IAAAA,IAAI,EAAE,gBAAY;AAChB,aAAO,UAAUD,SAAS,GAAGC,IAAZ,EAAV,GAA+B,GAAtC;AACD,KAHI;AAILC,IAAAA,GAAG,EAAE,eAAY;AACf,UAAIC,EAAJ;;AAEA,UAAIC,IAAI,GAAG,EAAX;;AAEA,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC5CD,QAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWC,SAAS,CAACD,EAAD,CAApB;AACD;;AAED,aAAO,CAACF,EAAE,GAAGH,SAAS,EAAf,EAAmBE,GAAnB,CAAuBM,KAAvB,CAA6BL,EAA7B,EAAiCR,aAAa,CAAC,EAAD,EAAKC,MAAM,CAACQ,IAAD,CAAX,CAA9C,CAAP;AACD,KAdI;AAeLK,IAAAA,KAAK,EAAE,iBAAY;AACjB,UAAIN,EAAJ;;AAEA,UAAIC,IAAI,GAAG,EAAX;;AAEA,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC5CD,QAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWC,SAAS,CAACD,EAAD,CAApB;AACD;;AAED,aAAO,CAACF,EAAE,GAAGH,SAAS,EAAf,EAAmBS,KAAnB,CAAyBD,KAAzB,CAA+BL,EAA/B,EAAmCR,aAAa,CAAC,EAAD,EAAKC,MAAM,CAACQ,IAAD,CAAX,CAAhD,CAAP;AACD,KAzBI;AA0BLM,IAAAA,iBAAiB,EAAE,6BAAY;AAC7B,UAAIP,EAAJ;;AAEA,UAAIC,IAAI,GAAG,EAAX;;AAEA,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC5CD,QAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWC,SAAS,CAACD,EAAD,CAApB;AACD;;AAED,aAAO,CAACF,EAAE,GAAGH,SAAS,EAAf,EAAmBU,iBAAnB,CAAqCF,KAArC,CAA2CL,EAA3C,EAA+CR,aAAa,CAAC,EAAD,EAAKC,MAAM,CAACQ,IAAD,CAAX,CAA5D,CAAP;AACD,KApCI;AAqCLO,IAAAA,mBAAmB,EAAE,+BAAY;AAC/B,UAAIR,EAAJ;;AAEA,UAAIC,IAAI,GAAG,EAAX;;AAEA,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC5CD,QAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWC,SAAS,CAACD,EAAD,CAApB;AACD;;AAED,aAAO,CAACF,EAAE,GAAGH,SAAS,EAAf,EAAmBW,mBAAnB,CAAuCH,KAAvC,CAA6CL,EAA7C,EAAiDR,aAAa,CAAC,EAAD,EAAKC,MAAM,CAACQ,IAAD,CAAX,CAA9D,CAAP;AACD,KA/CI;AAgDLQ,IAAAA,MAAM,EAAE,kBAAY;AAClB,UAAIT,EAAJ;;AAEA,UAAIC,IAAI,GAAG,EAAX;;AAEA,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC5CD,QAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWC,SAAS,CAACD,EAAD,CAApB;AACD;;AAED,aAAO,CAACF,EAAE,GAAGH,SAAS,EAAf,EAAmBY,MAAnB,CAA0BJ,KAA1B,CAAgCL,EAAhC,EAAoCR,aAAa,CAAC,EAAD,EAAKC,MAAM,CAACQ,IAAD,CAAX,CAAjD,CAAP;AACD,KA1DI;AA2DLS,IAAAA,QAAQ,EAAE,oBAAY;AACpB,UAAIV,EAAJ;;AAEA,UAAIC,IAAI,GAAG,EAAX;;AAEA,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC5CD,QAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWC,SAAS,CAACD,EAAD,CAApB;AACD;;AAED,aAAO,CAACF,EAAE,GAAGH,SAAS,EAAf,EAAmBa,QAAnB,CAA4BL,KAA5B,CAAkCL,EAAlC,EAAsCR,aAAa,CAAC,EAAD,EAAKC,MAAM,CAACQ,IAAD,CAAX,CAAnD,CAAP;AACD,KArEI;AAsELU,IAAAA,oBAAoB,EAAE,gCAAY;AAChC,UAAIX,EAAJ;;AAEA,UAAIC,IAAI,GAAG,EAAX;;AAEA,WAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGC,SAAS,CAACC,MAAhC,EAAwCF,EAAE,EAA1C,EAA8C;AAC5CD,QAAAA,IAAI,CAACC,EAAD,CAAJ,GAAWC,SAAS,CAACD,EAAD,CAApB;AACD;;AAED,aAAO,CAACF,EAAE,GAAGH,SAAS,EAAf,EAAmBc,oBAAnB,CAAwCN,KAAxC,CAA8CL,EAA9C,EAAkDR,aAAa,CAAC,EAAD,EAAKC,MAAM,CAACQ,IAAD,CAAX,CAA/D,CAAP;AACD;AAhFI,GAAP;AAkFD;;AAED,SAASN,IAAT","sourcesContent":["import { __spreadArray, __read } from 'tslib';\nimport { once } from '../utils.js';\n/**\r\n * Create a schema that lazily delegates to the given schema.\r\n */\n\nfunction lazy(schemaFn) {\n  var getSchema = once(schemaFn); // Memoize schema\n\n  return {\n    type: function () {\n      return \"Lazy<\" + getSchema().type() + \">\";\n    },\n    map: function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).map.apply(_a, __spreadArray([], __read(args)));\n    },\n    unmap: function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).unmap.apply(_a, __spreadArray([], __read(args)));\n    },\n    validateBeforeMap: function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).validateBeforeMap.apply(_a, __spreadArray([], __read(args)));\n    },\n    validateBeforeUnmap: function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).validateBeforeUnmap.apply(_a, __spreadArray([], __read(args)));\n    },\n    mapXml: function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).mapXml.apply(_a, __spreadArray([], __read(args)));\n    },\n    unmapXml: function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).unmapXml.apply(_a, __spreadArray([], __read(args)));\n    },\n    validateBeforeMapXml: function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return (_a = getSchema()).validateBeforeMapXml.apply(_a, __spreadArray([], __read(args)));\n    }\n  };\n}\n\nexport { lazy };"]},"metadata":{},"sourceType":"module"}